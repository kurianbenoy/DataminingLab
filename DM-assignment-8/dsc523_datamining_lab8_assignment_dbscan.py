# -*- coding: utf-8 -*-
"""DSC523-DataMining-Lab8-Assignment-DBSCAN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vNCupFsh902br3OBXQpD7-1XNvp_imgx
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import random

from google.colab import drive
drive.mount('/content/drive')

dataset = pd.read_csv('/content/drive/MyDrive/Mall_Customers.csv')

X = dataset.iloc[:, [3, 4]].values
X.shape

from sklearn.preprocessing import StandardScaler
X = StandardScaler().fit_transform(X)

plt.scatter(X[:,0],X[:,1],c='black',label='unclustered data')
plt.xlabel('Income')
plt.ylabel('Number of transactions')
plt.legend()
plt.title('Plot of data points')
plt.show()

def dbscan(D, eps, MinPts): 
    labels = [0]*len(D)  
    C = 0
    for P in range(0, len(D)):
    
        if not (labels[P] == 0):
           continue
        
        NeighborPts = region_query(D, P, eps)
        
        if len(NeighborPts) < MinPts:
            labels[P] = -1  
        else: 
           C += 1
           grow_cluster(D, labels, P, NeighborPts, C, eps, MinPts)
    
    return labels


def grow_cluster(D, labels, P, NeighborPts, C, eps, MinPts):
    labels[P] = C
    i = 0
    while i < len(NeighborPts):        
        Pn = NeighborPts[i]
        if labels[Pn] == -1:
           labels[Pn] = C
        elif labels[Pn] == 0:
            labels[Pn] = C
            
            PnNeighborPts = region_query(D, Pn, eps)
            
            if len(PnNeighborPts) >= MinPts:
                NeighborPts = NeighborPts + PnNeighborPts          
        i += 1        
    
def region_query(D, P, eps):
    neighbors = []
    for Pn in range(0, len(D)):
        if np.linalg.norm(D[P] - D[Pn]) < eps:
           neighbors.append(Pn)
            
    return neighbors

"""**Finding Optimal Value of EPS (Knee Method)**"""

#Finding Optimal Value of EPS (Knee Method)
from sklearn.neighbors import NearestNeighbors
nearest_neighbors = NearestNeighbors(n_neighbors=5)
nearest_neighbors.fit(X)
distances, indices = nearest_neighbors.kneighbors(X)
distances = np.sort(distances, axis=0)[:, 1]
print(distances)
plt.plot(distances)
plt.show()

"""Seems like 0.45 is optimal value for eps which yeilds maximum value."""

eps_value = 0.45
min_points = 10
my_labels = dbscan(X, eps=eps_value, MinPts=min_points)

my_labels = np.asarray(my_labels)

# Visualising the clusters (DBSCAN Scratch Implementation)
plt.scatter(X[my_labels == 1, 0], X[my_labels == 1, 1], s = 100, c = 'red', label = 'Cluster 1')
plt.scatter(X[my_labels == 2, 0], X[my_labels == 2, 1], s = 100, c = 'blue', label = 'Cluster 2')
plt.scatter(X[my_labels == 3, 0], X[my_labels == 3, 1], s = 100, c = 'green', label = 'Cluster 3')
plt.scatter(X[my_labels == 4, 0], X[my_labels == 4, 1], s = 100, c = 'cyan', label = 'Cluster 4')

plt.scatter(X[my_labels == -1, 0], X[my_labels == -1 , 1], s = 10, c = 'magenta', label = 'Noise')
plt.title('Clusters of customers')
plt.xlabel('Annual Income (k$)')
plt.ylabel('Spending Score (1-100)')
plt.legend()
plt.show()

"""**DBSCAN Sklearn implementation**"""

from sklearn.cluster import DBSCAN

db = DBSCAN(eps=eps_value, min_samples=min_points).fit(X)

skl_labels = db.labels_
skl_labels

for i in range(0, len(skl_labels)):
    if not skl_labels[i] == -1:
        skl_labels[i] += 1

skl_labels

result = np.where(skl_labels == -1)

# Datas indices with noise (-1)
result

result = np.where(skl_labels == 1)
# Data indices with clustor 1 
result

result = np.where(skl_labels == 2)
# Data indices with clustor 2
result

result = np.where(skl_labels == 3)
# Data indices with clustor 3
result

result = np.where(skl_labels == 4)
# Data indices with clustor 4 
result

num_disagree = 0

for i in range(0, len(skl_labels)):
    if not skl_labels[i] == my_labels[i]:
        print('Scikit learn:', skl_labels[i], 'mine:', my_labels[i])
        num_disagree += 1

if num_disagree == 0:
    print('PASS - All labels match!')
else:
    print('FAIL -', num_disagree, 'labels don\'t match.' )

# Visualising the clusters
plt.scatter(X[skl_labels == 1, 0], X[skl_labels == 1, 1], s = 100, c = 'red', label = 'Cluster 1')
plt.scatter(X[skl_labels == 2, 0], X[skl_labels == 2, 1], s = 100, c = 'blue', label = 'Cluster 2')
plt.scatter(X[skl_labels == 3, 0], X[skl_labels == 3, 1], s = 100, c = 'green', label = 'Cluster 3')
plt.scatter(X[skl_labels == 4, 0], X[skl_labels == 4, 1], s = 100, c = 'cyan', label = 'Cluster 4')

plt.scatter(X[skl_labels == -1, 0], X[skl_labels == -1 , 1], s = 10, c = 'magenta', label = 'Noise')
plt.title('Clusters of customers')
plt.xlabel('Annual Income (k$)')
plt.ylabel('Spending Score (1-100)')
plt.legend()
plt.show()

# Evaluating the quality of clusters
from sklearn.metrics import silhouette_score
s = silhouette_score(X, db.labels_)
print(f"Silhouette Coefficient for the Mall Customer Dataset Clusters: {s:.2f}")